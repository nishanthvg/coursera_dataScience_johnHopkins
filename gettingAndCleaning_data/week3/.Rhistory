print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(4,4)
print(f)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
##column and row binding
g <- 1:3
h <- 4:7
cbind(g,h)
rbind(g,h)
h <- 4:6
View(f)
rbind(g,h)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
##column and row binding
g <- 1:3
h <- 4:6
cbind(g,h)
rbind(g,h)
##factors - catagorial array that is character array which can be used for ordered and unordered list
i <- factor(c("yes","yes","no","no"))
print(i)
table(i)
unclass(i)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
##column and row binding
g <- 1:3
h <- 4:6
cbind(g,h)
rbind(g,h)
##factors - catagorial array that is character array which can be used for ordered and unordered list
i <- factor(c("yes","yes","no","no"))
print(i)
table(i)
unclass(i)
##levels can be set for explicitly mentioning the order - compare it with the above
j <- factor(c("yes","yes","no","no"), levels = c("yes", "no"))
print(j)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
##column and row binding
g <- 1:3
h <- 4:6
cbind(g,h)
rbind(g,h)
##factors - catagorial array that is character array which can be used for ordered and unordered list
i <- factor(c("yes","yes","no","no"))
print(i)
table(i)
unclass(i)
##levels can be set for explicitly mentioning the order - compare it with the above
j <- factor(c("yes","yes","no","no"), levels = c("yes", "no"))
print(j)
##MIssing values na and nan - all nan are na but all na are not nan
k <- c(1,2,3,NA,NaN)
is.na(k)
is.nan(k)
##if else statement
x=2
x
##if else statement
x=2
if(x > 2) {
y = 3
} else {
y =4
}
print(y)
y <- if(x > 3) {
3
} else {
4
}
print(y)
a = c("a","b","c")
seq_along(a)
##if else statement
x=2
if(x > 2) {
y = 3
} else {
y =4
}
print(y)
y <- if(x > 3) {
3
} else {
4
}
print(y)
## for loop
a = c("a","b","c")
for(i in 1:3) {
print(a[i])
}
for(i in seq_along(a)) {
print(a[i])
}
for(letter in a) {
print(letter)
}
for(i in 1:3) print(a[i])
##nested loop
b = matrix(1:6,2,3)
for(i in seq_along(nrow(b))) {
for(j in seq_along(ncol(b))) {
print(b[i][j])
}
}
print(b[i,j])
b = matrix(1:6,2,3)
for(i in seq_along(nrow(b))) {
for(j in seq_along(ncol(b))) {
print(b[i,j])
}
}
b = matrix(1:6,2,3)
for(i in seq_len(nrow(b))) {
for(j in seq_len(ncol(b))) {
print(b[i,j])
}
}
##while loop
c = 0
while(count < 2) {
print(count)
count++
}
c = 0
while(count < 2) {
print(count)
count <- count + 1
}
count = count + 1
##while loop
count = 0
##while loop
count = 0
while(count < 2) {
print(count)
count = count + 1
}
x = 0
repeat {
if(x > 2) {
break
}
x = x +1
}
print(x)
##next - used to skip an iteration
for(i in 1:30) {
if(i <= 20){
next
}
print(i)
}
m <- numeric(10)
print(m)
class(m)
install.packages("swirl")
packageVersion("swirl")
library(swirl)
swirl()
0
#lapply - returns a list
#arguments - list, function
x <- 1:4
lapply(x, mean)
lapply(x, function(ele) ele = ele +1)
lapply(x, function(ele) ele = ele +1, min = 0, max = 5)
lapply(x, runif, min = 0, max = 9) #creates a uniform random variables - runif
rnorm(10)
rnorm(10,1)
x1 <- list(a = 1:4, b = rnorm(10), c = rnorm(20)
sapply(x1, mean)
x1 <- list(a = 1:4, b = rnorm(10), c = rnorm(20))
sapply(x1, mean)
20, 10)
colSum = apply(x2, 2, sum)
rowSum = apply(x2, 1, sum)
colMean = apply(x2, 2, mean)
colSum = apply(x2,1,mean)
x2 <- matrix(rnorm(200), 20, 10)
colSum = apply(x2, 2, sum)
rowSum = apply(x2, 1, sum)
colMean = apply(x2, 2, mean)
colSum = apply(x2,1,mean)
colSum
culMean
x2 <- matrix(rnorm(200), 20, 10)
colSum = apply(x2,1, sum)
rowSum = apply(x2, 2, sum)
colMean = apply(x2, 1, mean)
rowSum = apply(x2,2,mean)
colSum
x2 <- matrix(rnorm(200), 20, 10)
colSum = apply(x2,2, sum)
rowSum = apply(x2, 1, sum)
colMean = apply(x2, 2, mean)
rowMean = apply(x2,1,mean)
colSum
rowSum
#ANOTHER EXAMPLE
apply(x2,1,quantile,probs = c(0.25,0.75)) #finding the 25 and the 75th percentiel forevery row
#mapply - helps in itrating through the arguments
noise <- function(n, mean, sd) {
rnorm(n,mean,sd)
}
#say we have an array of n and array of mean for which we need norm
mapply(noise, 1:5,1:5,2)
x <- list(rnorm(10), runif(10, rnorm(10))
f <- gl(3,10)
tapply(x,f,mean)
x4 <- list(rnorm(10), runif(10, rnorm(10))
f1 <- gl(3,10)
tapply(x,f,mean)
x4 <- list(rnorm(10), runif(10), rnorm(10))
f1 <- gl(3,10)
tapply(x,f,mean)
#tapply
x4 <- c(rnorm(10), runif(10), rnorm(10))
f1 <- gl(3,10)
tapply(x,f,mean)
#tapply
x4 <- c(rnorm(10), runif(10), rnorm(10,1))
f1 <- gl(3,10)
tapply(x,f,mean)
f1
x4
length(f1)
length(x4)
#tapply
x4 <- c(rnorm(10), runif(10), rnorm(10,1))
f1 <- gl(3,10)
tapply(x4,f1,mean)
tapply(x4,f1,mean)
tapply(x4, f1, mean, simplify = FALSE)
library(xlsx)
#XML
library(XML)
install.packages("RMySQL")
ucscDB <- dbConnect(MySQL(), user="genome", host = "genome-mysql.soe.ucsc.edu")
result <- dbGetQuery(ucsDb, "show database;"); dbDisconnect(ucscDB);
ucscDB <- dbConnect(MySQL(), user="genome", host="genome-mysql.soe.ucsc.edu")
result <- dbGetQuery(ucscDb, "show database;"); dbDisconnect(ucscDB);
library(RMySQL)
ucscDB <- dbConnect(MySQL(), user="genome", host="genome-mysql.soe.ucsc.edu")
result <- dbGetQuery(ucscDb, "show database;"); dbDisconnect(ucscDB);
result <- dbGetQuery(ucscDb,"show databases;"); dbDisconnect(ucscDB);
ucscDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.soe.ucsc.edu")
result <- dbGetQuery(ucscDb,"show databases;"); dbDisconnect(ucscDB);
result
#specific database in the server
hg19 <- dbConnect(MySQL(), user="genome",db="hg19" ,host="genome-mysql.soe.ucsc.edu")
allTables <- dbListTables(hg19)
allTables
allTables[1:5]
#specific table from hg19
specificTable <- dbListTables(hg19,"affyU133Plus2")
specificTable
#specific table from hg19
specificTable <- dbListFields(hg19,"affyU133Plus2")
specificTable
#to get the rows count
specificTable_rowCount <- dbGetQuery(hg19, "specific count(*) from addyU133Plus2")
#to get the rows count
specificTable_rowCount <- dbGetQuery(hg19, "select count(*) from addyU133Plus2")
#to get the rows count
specificTable_rowCount <- dbGetQuery(hg19, "select count(*) from affyU133Plus2")
specificTable_rowCount
#specific table from hg19
specificTable <- dbReadTable(hg19, "affyU133Plus2")
warning()
head(specificTable)
#specific subset from a table
query <- dbSendQuery(hg19,"select * from affyU133Plus2 where mismatch between 1 and 3")
#specific subset from a table
query <- dbSendQuery(hg19,"select * from affyU133Plus2 where misMatches between 1 and 3")
query <- dbSendQuery(hg19,"select * from affyU133Plus2 where misMatches between 1 and 3")
affyMis <- fetch(query) ;qunatile(ffyMis$misMatches))
#specific subset from a table
query <- dbSendQuery(hg19,"select * from affyU133Plus2 where misMatches between 1 and 3")
#specific subset from a table
query <- dbSendQuery(hg19,"select * from affyU133Plus2 where misMatches between 1 and 3")
dbDisconnect(hg19)
hg19 <- dbConnect(MySQL(), user="genome",db="hg19" ,host="genome-mysql.soe.ucsc.edu")
allTables <- dbListTables(hg19)
#specific table from hg19
specificTable <- dbReadTable(hg19, "affyU133Plus2")
head(specificTable)
#specific table from hg19 - listing all the fields that is column names
specificTable_col <- dbListFields(hg19,"affyU133Plus2")
#to get the rows count
specificTable_rowCount <- dbGetQuery(hg19, "select count(*) from affyU133Plus2")
#specific subset from a table
query <- dbSendQuery(hg19,"select * from affyU133Plus2 where misMatches between 1 and 3")
affyMis <- fetch(query) ;qunatile(ffyMis$misMatches)
qunatile(ffyMis$misMatches)
affyMis <- fetch(query); quantile(ffyMis$misMatches)
affyMis <- fetch(query); quantile(affyMis$misMatches)
#to select small portion
affyMisSmall<- fetch(query, n=10); dbClearResult(query)
dbDisconnect(hg19)
source("http://bioconductor.org/biocLite.R")
biocLite("rhdf5")
install(BiocManager)
install.packages("BiocManager")
source("http://bioconductor.org/biocLite.R")
BiocManager::install("biocLite.R")
source("http://bioconductor.org/biocLite.R")
source("http://bioconductor.org/biocLite.R")
BiocManager::install("BiocManager")
BiocManager::install("biocLite.R")
BiocManager::install("rhdf5")
library(rhdf5)
created = h5createFile("example.h5")
created
created = h5createGroup("example.h5", "foo")
created = h5createGroup("example.h5", "baa")
created = h5createGroup("example.h5", "foo/foobaa")#sub group foo
created
h5ls(created)
h5ls("example.h5")
#write to groups
a = matrix(1:10,5,2)
#write to groups
a = matrix(1:10,5,2)
h5write(a,"example.R", "foo/a")
h5ls("example.R")
5,2)
h5write(a,"example.h5", "foo/a")
h5ls("example.h5
a = matrix(1:10,5,2)
h5write(a,"example.h5", "foo/a")
h5ls("example.h5")
#reading data
readA = h5read("example.h5","foo/a")
readA
#updating a group
h5write(c(13,12,11),"example.h5", "foo/a", index =list(1:3,1))
h5ls("example.h5")
readA = h5read("example.h5","foo/a")
readA
install.packages("dplyr")
library(dplyr)
library(dplyr)
data <- readRDS("./data/chicago.rds")
# 3. make handle
fileURL <- "https://github.com/DataScienceSpecialization/courses/blob/master/03_GettingData/dplyr/chicago.rds?raw=true"
# 4. download data
download.file(fileURL, destfile = "./data/chicago.rds", method = "curl", extra='-L')
data <- readRDS("./data/chicago.rds")
setwd("~/Documents/Education/coursera_data_scince/gettingAndCleaning_data/week3")
# 3. make handle
fileURL <- "https://github.com/DataScienceSpecialization/courses/blob/master/03_GettingData/dplyr/chicago.rds?raw=true"
# 4. download data
download.file(fileURL, destfile = "./data/chicago.rds", method = "curl", extra='-L')
data <- readRDS("./data/chicago.rds")
head(data, n = 3)
names(data)
#select statement
head(select(chicago, city:dptp))
#select statement
head(select(chic, city:dptp))
library(dplyr)
#select statement
head(select(chicago, city:dptp))
#select statement
head(select(chicago, -(city:dptp)))
#select statement
head(select("chicago", -(city:dptp)))
chicago
str(chicagi)
str(chicago)
str(data)
#select statement
head(select(data, -(city:dptp)))
#select statement
head(select(data, (city:dptp)))
j <- matcg("dptp", names(data))
i <- match("city", names(data))
j <- match("dptp", names(data))
head(data[, [i:j]])
head(data[, i:j])
head(select(datam -(city:dptp)))
