attributes(d) ## gives all the methods used on matrix and its value
example <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(4,4)
print(f)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
##column and row binding
g <- 1:3
h <- 4:7
cbind(g,h)
rbind(g,h)
h <- 4:6
View(f)
rbind(g,h)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
##column and row binding
g <- 1:3
h <- 4:6
cbind(g,h)
rbind(g,h)
##factors - catagorial array that is character array which can be used for ordered and unordered list
i <- factor(c("yes","yes","no","no"))
print(i)
table(i)
unclass(i)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
##column and row binding
g <- 1:3
h <- 4:6
cbind(g,h)
rbind(g,h)
##factors - catagorial array that is character array which can be used for ordered and unordered list
i <- factor(c("yes","yes","no","no"))
print(i)
table(i)
unclass(i)
##levels can be set for explicitly mentioning the order - compare it with the above
j <- factor(c("yes","yes","no","no"), levels = c("yes", "no"))
print(j)
x <- c("1","2") ##any data type can be implemented, the c function will automatically detect it
y <- vector("numeric", length = 10) ## default intialisation
##if in c function, elements are of not same type, then it chooses any one of the type
z <- c(1, "a")
## explicit typecasting or also called as coersion
a <- 1.3
class(a)
as.character(a)
##sequence of number
b <- 0:7
class(b)
as.logical(b)
##list - element in the list can contain multiple  data type
c = list(1, "!", TRUE, 1+0i) ## [[]] -> are the index
##matrix - are filled col wise - can be seen in the examples 2
d <- matrix(nrow = 2, ncol = 2)
print(d)
dim(d) ##gives dimension that is size of row and col
attributes(d) ## gives all the methods used on matrix and its value
ex1 <- matrix(c(1,2,3,4,5,6,7,8), nrow = 4, ncol = 2) ##example
ex2 <- matrix(1:8, nrow = 4, ncol = 4)
print(ex2)
##vector to matrix
f <- 1:8
dim(f) <- c(2,4)
print(f)
##column and row binding
g <- 1:3
h <- 4:6
cbind(g,h)
rbind(g,h)
##factors - catagorial array that is character array which can be used for ordered and unordered list
i <- factor(c("yes","yes","no","no"))
print(i)
table(i)
unclass(i)
##levels can be set for explicitly mentioning the order - compare it with the above
j <- factor(c("yes","yes","no","no"), levels = c("yes", "no"))
print(j)
##MIssing values na and nan - all nan are na but all na are not nan
k <- c(1,2,3,NA,NaN)
is.na(k)
is.nan(k)
##if else statement
x=2
x
##if else statement
x=2
if(x > 2) {
y = 3
} else {
y =4
}
print(y)
y <- if(x > 3) {
3
} else {
4
}
print(y)
a = c("a","b","c")
seq_along(a)
##if else statement
x=2
if(x > 2) {
y = 3
} else {
y =4
}
print(y)
y <- if(x > 3) {
3
} else {
4
}
print(y)
## for loop
a = c("a","b","c")
for(i in 1:3) {
print(a[i])
}
for(i in seq_along(a)) {
print(a[i])
}
for(letter in a) {
print(letter)
}
for(i in 1:3) print(a[i])
##nested loop
b = matrix(1:6,2,3)
for(i in seq_along(nrow(b))) {
for(j in seq_along(ncol(b))) {
print(b[i][j])
}
}
print(b[i,j])
b = matrix(1:6,2,3)
for(i in seq_along(nrow(b))) {
for(j in seq_along(ncol(b))) {
print(b[i,j])
}
}
b = matrix(1:6,2,3)
for(i in seq_len(nrow(b))) {
for(j in seq_len(ncol(b))) {
print(b[i,j])
}
}
##while loop
c = 0
while(count < 2) {
print(count)
count++
}
c = 0
while(count < 2) {
print(count)
count <- count + 1
}
count = count + 1
##while loop
count = 0
##while loop
count = 0
while(count < 2) {
print(count)
count = count + 1
}
x = 0
repeat {
if(x > 2) {
break
}
x = x +1
}
print(x)
##next - used to skip an iteration
for(i in 1:30) {
if(i <= 20){
next
}
print(i)
}
m <- numeric(10)
print(m)
class(m)
install.packages("swirl")
packageVersion("swirl")
library(swirl)
swirl()
0
setwd("~/Documents/Education/coursera_data_scince/R_prog/week2")
ls
pwd
setwd("~/Documents/Education/coursera_data_scince/R_prog/week2")
data <- list.files("~/Documents/Education/coursera_data_scince/R_prog/week2")
data
pollutant <- function(directory, pollutant, id=1:332) {
pollutants = c()
filenames = list.files(directory)
for(i in id) {
filepath = paste(directory, "/", filename[i], sep="")
data = read.csv(filepath, header = TRUE)
pollutants = c(pollutants, data[ ,pollutant])
}
pollutantMean = mean(pollutants, is.na = TRUE)
}
specdataFIle <- "~/Documents/Education/coursera_data_scince/R_prog/week2/specdata"
pollutant(specdataFIle, "sulfate", 1:332)
pollutant <- function(directory, pollutant, id=1:332) {
pollutants = c()
filenames = list.files(directory)
for(i in id) {
filepath = paste(directory, "/", filenames[i], sep="")
data = read.csv(filepath, header = TRUE)
pollutants = c(pollutants, data[ ,pollutant])
}
pollutantMean = mean(pollutants, is.na = TRUE)
}
pollutant(specdataFIle, "sulfate", 1:332)
pollutant <- function(directory, pollutant, id=1:332) {
pollutants = c()
filenames = list.files(directory)
for(i in id) {
filepath = paste(directory, "/", filenames[i], sep="")
data = read.csv(filepath, header = TRUE)
pollutants = c(pollutants, data[ ,pollutant])
}
pollutantMean = mean(pollutants, is.na = TRUE)
pollutantMean
}
pollutant(specdataFIle, "sulfate", 1:332)
pollutant <- function(directory, pollutant, id=1:332) {
pollutants = c()
filenames = list.files(directory)
for(i in id) {
filepath = paste(directory, "/", filenames[i], sep="")
data = read.csv(filepath, header = TRUE)
pollutants = c(pollutants, data[ ,pollutant])
}
pollutantMean = mean(pollutants, na.rm = TRUE)
pollutantMean
}
pollutant(specdataFIle, "sulfate", 1:332)
pollutant(specdataFIle, "sulfate", 1:10)
pollutantmean(specdataFIle, "nitrate", 70:72)
pollutant(specdataFIle, "sulfate", 70:72)
pollutant(specdataFIle, "nitrate", 70:72)
pollutant(specdataFIle, "nitrate", 23)
filename = list.files(specdataFIle)
filename
filepath = paste(specdataFIle, "/", filename[0], sep="")
filepath
filepath = paste(specdataFIle, "/", filename[1], sep="")
filepath
data = read.csv(filepath, header = TRUE)
data
clear()
completeData = data[complete.cases(data), ]
completeData
completeData
completeData
nrows(completeData)
nrow(completeData)
completeData
pollutant <- function(directory, pollutant, id=1:332) {
pollutants = c()
filenames = list.files(directory)
for(i in id) {
filepath = paste(directory, "/", filenames[i], sep="")
data = read.csv(filepath, header = TRUE)
pollutants = c(pollutants, data[ ,pollutant])
}
pollutantMean = mean(pollutants, na.rm = TRUE)
pollutantMean
}
complete <- function(directory, id = 1:332) {
ids = c()
nobbs = c()
filenames = list.files(directory)
for(i in id) {
filepath = paste(directory, "/", filenames[i], sep="")
data = read.csv(filepath, header=TRUE)
completeData = data[complete.cases(data), ]
ids = c(ids, i)
nobbs = c(nobbs, nrows(completeData))
}
data.frame(id = ids, nobs = nobbs)
}
complete(specdataFIle, c(2, 4, 8, 10, 12))
pollutant <- function(directory, pollutant, id=1:332) {
pollutants = c()
filenames = list.files(directory)
for(i in id) {
filepath = paste(directory, "/", filenames[i], sep="")
data = read.csv(filepath, header = TRUE)
pollutants = c(pollutants, data[ ,pollutant])
}
pollutantMean = mean(pollutants, na.rm = TRUE)
pollutantMean
}
complete <- function(directory, id = 1:332) {
ids = c()
nobbs = c()
filenames = list.files(directory)
for(i in id) {
filepath = paste(directory, "/", filenames[i], sep="")
data = read.csv(filepath, header=TRUE)
completeData = data[complete.cases(data), ]
ids = c(ids, i)
nobbs = c(nobbs, nrow(completeData))
}
data.frame(id = ids, nobs = nobbs)
}
complete(specdataFIle, c(2, 4, 8, 10, 12))
pollutant(specdataFIle, "sulfate", 34)
pollutant(specdataFIle, "nitrate")
complete(specdataFIle, c(6, 10, 20, 34, 100, 200, 310))
complete(specdataFIle, 54)
RNGversion("3.5.1")
set.seed(42)
cc <- complete(specdataFIle, 332:1)
use <- sample(332, 10)
print(cc[use, "nobs"])
corr <- function(directory, threshold = 0){
completes = complete(directory, 1:332)
completes_above_threshold = subset(completes, nobs > threshold )
## Initialize empty vector variable
correlations <- vector()
## Get a list of filenames
filenames = list.files(directory)
## For each .csv file in id
for(i in completes_above_threshold$id){
## Concatinate the directory and filename
## e.g. directory = "C:/folder", filenames = vector("001.csv", "002.csv", ...), filepath="C:/folder/001.csv"
filepath=paste(directory,"/" ,filenames[i], sep="")
## read in each file and store it in data
data = read.csv(filepath, header = TRUE)
## Calculate and store the number of completed cases
completeCases = data[complete.cases(data),]
count = nrow(completeCases)
## Calculate and store the count of complete cases
## if threshhold is reached
if( count >= threshold ) {
correlations = c(correlations, cor(completeCases$nitrate, completeCases$sulfate) )
}
}
correlations
}
cr <- corr(specdataFIle)
cr <- sort(cr)
RNGversion("3.5.1")
set.seed(868)
out <- round(cr[sample(length(cr), 5)], 4)
print(out)
cr <- corr(specdataFIle, 129)
cr <- sort(cr)
n <- length(cr)
RNGversion("3.5.1")
set.seed(197)
out <- c(n, round(cr[sample(n, 5)], 4))
print(out)
cr <- corr(specdataFIle, 2000)
n <- length(cr)
cr <- corr(specdataFIle, 1000)
cr <- sort(cr)
print(c(n, round(cr, 4)))
